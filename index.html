<!doctype html>
<html>
<head>
  <title>Snake</title>
  <style>
    body {
      background: #444;
      text-align: center;
      margin: 64px 0 0 0;
      /*background: black;*/
      /*background: linear-gradient(
        0deg,
        rgba(0, 102, 204, 1.0) 0%,
        rgba(125, 60, 152, 1.0) 100%
      );*/
    }
    canvas {
      background: black;
      /*background: linear-gradient(
        0deg,
        rgba(0, 102, 204, 1.0) 0%,
        rgba(125, 60, 152, 1.0) 100%
      );*/
    }
  </style>
</head>
<body>

<canvas width="500" height="500"></canvas>

<script>
  console.log("inicio")
  const STATE_RUNNING = 1;
  const STATE_LOSING = 2;
  const colores = {
    serpiente: 'white',
    manzana: 'red'
  }
  const TICK = 100;
  const SQUARE_SIZE = 25;
  const BOARD_WIDTH = 19;
  const BOARD_HEIGHT = 19;
  const GROW_SCALE = 3;
  const DIRECTIONS_MAP = {
    'A': [-1,  0],
    'D': [ 1,  0],
    'S': [ 0,  1],
    'W': [ 0, -1],
    'a': [-1,  0],
    'd': [ 1,  0],
    's': [ 0,  1],
    'w': [ 0, -1],
  };

  let state = {
    canvas: null,
    context: null,
    snake: [{x: 0, y: 0}],
    direction: {x: 1, y: 0},
    direction_past: {x: 1, y: 0},
    prey: {x: 0, y: 0},
    growing: 0,
    runState: STATE_RUNNING,
    iterations: 0
  };
  function sleep(milliseconds) {
    const date = Date.now();
    let currentDate = null;
    do {
      currentDate = Date.now();
    } while (currentDate - date < milliseconds);
  }
  alert("antes")
  sleep(1000)
  alert("despues")
  /*function randomXY(){ // No quiere funcionar
    var conflicto = false
    state.prey = {
      x: parseInt(Math.random() * BOARD_WIDTH),
      y: parseInt(Math.random() * BOARD_HEIGHT)
    };
    for (let idx = 0; idx < state.snake.length; idx++){
      if (state.prey.x !== state.snake[idx].x && state.prey.y !== state.snake[idx].y){
        conflicto = true
      }
    }
    while (conflicto){
      conflicto = false
      for (let idx = 0; idx < state.snake.length; idx++){
        if (state.prey.x == state.snake[idx].x && state.prey.y === state.snake.y){
          conflicto = true
          console.log("x")
        }
      }
      if (conflicto){
        state.prey = {
          x: parseInt(Math.random() * BOARD_WIDTH),
          y: parseInt(Math.random() * BOARD_HEIGHT)
        };
      }

    }
    return state.prey
  }*/
  function randomXY(){ // FUNCIONAAAAAAAAAAAAAAAAAAAAAA LO LOGRE
    let conflicto = false; // Esta función ubica la manzana en cualquier lugar del lienzo, verifica si quedó encima (o debajo, en este caso; dependiendo de cual se dibuje primero) y si es verdad, la vuelve a reubicar hasta que no lo sea. (La variable conflicto es true si está encima, y false si no lo está)
    coordenadas = {
      x: parseInt(Math.random() * BOARD_WIDTH),
      y: parseInt(Math.random() * BOARD_HEIGHT)
    };
    for (let i = 0; i < state.snake.length; i++){
      if (state.snake[i].x === coordenadas.x
        && state.snake[i].y === coordenadas.y){
          conflicto = true;
      } else {
        const bloque = i+1
        //console.log("No está encima del bloque "+bloque);
      }
    }
    if (conflicto){
      console.log("No pasó la primera prueba");
      while (conflicto){
        coordenadas = {
          x: parseInt(Math.random() * BOARD_WIDTH),
          y: parseInt(Math.random() * BOARD_HEIGHT)
        };
        conflicto = false;
        for (let i = 0; i < state.snake.length; i++){
          if (state.snake[i].x === coordenadas.x
            && state.snake[i].y === coordenadas.y){
            conflicto = true;
          } else {
            const bloque = i+1
            //console.log("No está encima del bloque "+bloque);
          }
        }
      }
      console.log("Pasó la segunda prueba");
    } else {
      console.log("Pasó la primera prueba");
    }
    state.prey.x = coordenadas.x;
    state.prey.y = coordenadas.y;
  }

  function tick() {
    const head = state.snake[0];
    const dx = state.direction.x;
    const dy = state.direction.y;
    const highestIndex = state.snake.length - 1;
    let tail = {};
    let interval = TICK;

    Object.assign(tail,
      state.snake[state.snake.length - 1]);

    let didScore = (
      head.x === state.prey.x
      && head.y === state.prey.y
    );

    if (state.runState === STATE_RUNNING) {
      for (let idx = highestIndex; idx > -1; idx--) {
        const sq = state.snake[idx];

        if (idx === 0) {
          sq.x += dx;
          sq.y += dy;
        } else {
          sq.x = state.snake[idx - 1].x;
          sq.y = state.snake[idx - 1].y;
        }
      }
    } else if (state.runState === STATE_LOSING) {
      interval = 10;

      if (state.snake.length > 0) {
        if (state.snake.length === 1){
          sleep(500)
        }
        state.snake.splice(0, 1);
      }

      if (state.snake.length === 0) {
        state.runState = STATE_RUNNING;
        state.snake = [{x: 0, y: 0}],
        state.direction = {x:1,y:0}
        state.prey = {
          x: parseInt(Math.random() * BOARD_WIDTH),
          y: parseInt(Math.random() * BOARD_HEIGHT)
        };;
        state.iterations = 0
        state.growing = 4;
      }
    }

    if (detectCollision()) {
      state.runState = STATE_LOSING;
      state.growing = 0;
    }

    if (didScore) {
      state.growing += GROW_SCALE;
      randomXY();
    }

    if (state.growing > 0 && state.iterations > 0) {
      state.snake.push(tail);
      state.growing -= 1;
    }
    state.iterations++

    requestAnimationFrame(draw);
    setTimeout(tick, interval);
  }

  function detectCollision() {
    const head = state.snake[0];

    if (head.x < 0
      || head.x >= BOARD_WIDTH
      || head.y >= BOARD_HEIGHT
      || head.y < 0
    ) {
      return true;
    }

    for (var idx = 1; idx < state.snake.length; idx++) {
      const sq = state.snake[idx];

      if (sq.x === head.x && sq.y === head.y) {
        return true;
      }
    }

    return false;
  }

  function drawPixel(color, x, y) {
    state.context.fillStyle = color;
    state.context.fillRect(
      x * SQUARE_SIZE,
      y * SQUARE_SIZE,
      SQUARE_SIZE,
      SQUARE_SIZE
    );
  }

  function draw() {
    state.context.clearRect(0, 0, 500, 500);
    const {x, y} = state.prey;
    drawPixel(colores.manzana, x, y);
    for (var idx = 0; idx < state.snake.length; idx++) {
      const {x, y} = state.snake[idx];
      drawPixel(colores.serpiente, x, y);
    }
    state.direction_past.x = "e"
    state.direction_past.y = "e"
  }

  window.onload = function() {
    state.canvas = document.querySelector('canvas');
    state.context = state.canvas.getContext('2d');

    window.onkeydown = function(e) {
      const direction = DIRECTIONS_MAP[e.key];

      if (direction) {
        const [x, y] = direction;
        if (-x !== state.direction.x && -y !== state.direction.y
        && -x !== state.direction_past.x && -y !== state.direction.y)
        {
          state.direction_past.x = state.direction.x
          state.direction_past.y = state.direction.y
          state.direction.x = x;
          state.direction.y = y;
        }
      }
    }

    tick();
  };
</script>

</body>
</html>
